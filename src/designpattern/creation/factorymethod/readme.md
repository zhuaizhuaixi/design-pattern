## 工厂方法模式

导致简单工厂模式不符合开闭原则的原因是工厂方法只是一个实类。

设计者提出：可以将工厂类改写为一个层次类来解决问题

UML图：
![Alt text](../../../../img/factoryMethodUML.jpg)

简单工厂方法模式与工厂方法模式的区别：
1. 中心不同：工厂方法模式中心是工厂接口，简单模式的中心是工厂类
2. 简单工厂方法模式不支持开闭原则，而工厂方法模式支持。在工厂方法模式中要添加新产品，只需新增一个具体的Creator类和具体的Product类即可，无须修改客户端代码
3. 简单模式中逻辑判断包含在工厂类中，而工厂方法模式的工厂类不包括逻辑判断

使用工厂方法模式的场景
1. 创建类的逻辑比较复杂，且有很多条件分支，将来有可能新增条件
2. 无法准确的知道需要创建层次类中哪个子类的对象
3. 一个类使用子类决定要创建的对象
4. 需要封装创建类的逻辑

工厂方法模式的优点：
1. 创建对象的逻辑和任务交给工厂类
2. 支持**开闭原则**

**工厂方法模式的两种设计**：
1. 在客户类中创建具体的工厂子类对象，利用这些对象创建产品类对象，最后利用改对象调用产品类方法。如此设计下，创建工厂子类对象的条件语句出现在客户雷中，而工厂类中没有与创建子类相关的条件语句。这种情况下，工厂方法模式**符合开闭原则**
2. 将工厂层次类的超类设计为抽象类，并且有个静态方法用于动态获取工厂类，根据参数返回具体的工厂类对象，好处是将判断的条件语句交给工厂超类。在修改产品类时不需要修改客户类和工厂类代码，在新增产品子类时只需要相应新增一个工厂子类即可（但当客户需要使用新增的产品时，需要对超类静态方法进行修改），**符合开闭原则**。
